<!DOCTYPE html>
<html>
<head>
    <title>Générateur TP Minecraft Tinel25</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .layout {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        form {
            flex: 1;
            max-width: 400px;
        }

        .visuals {
            display: flex;
            gap: 20px;
        }

        canvas, #threeContainer {
            border: 1px solid #000;
            width: 500px;
            height: 500px;
            margin-top: 20px;
        }

        h1 {
            margin-bottom: 20px;
        }

        h2 {
            margin-top: 0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
</head>
<body>
    <h1>Générateur de commandes TP Minecraft</h1>
    <div class="layout">
        <form method="post">
            <!-- Formulaire inchangé -->
            <label>Départ (x,y,z):</label><br>
            <input name="start" value="0,0,0"><br><br>

            <label>Arrivée (x,y,z):</label><br>
            <input name="end" value="0,0,0"><br><br>

            <label>Point de contrôle (x,y,z) <em>(laisser vide pour auto)</em>:</label><br>
            <input name="control" placeholder="auto"><br><br>

            <label>Décalage X du point de contrôle:</label><br>
            <input name="offset_x" value="0"><br><br>

            <label>Décalage Y du point de contrôle:</label><br>
            <input name="offset_y" value="0"><br><br>

            <label>Décalage Z du point de contrôle:</label><br>
            <input name="offset_z" value="0"><br><br>

            <label>UUID:</label><br>
            <input name="uuid" value="test-uuid"><br><br>

            <label>Vitesse (blocs/sec):</label><br>
            <input name="speed" value="4.317"><br><br>

            <label>Tick interval:</label><br>
            <input name="tick_interval" value="2"><br><br>

            <label>Delay personnalisé (en ticks):</label><br>
            <input name="delay_ticks" value="2.8"><br><br>

            <button type="submit">Générer</button>
        </form>

        <div class="visuals">
            <div>
                <h2>Visualisation 2D (X-Z)</h2>
                <canvas id="bezierCanvas" width="500" height="500"></canvas>
            </div>
            <div>
                <h2>Visualisation 3D</h2>
                <div id="threeContainer"></div>
            </div>
        </div>
    </div>

    <script>
        function parseCoords(input) {
            return input.split(',').map(Number);
        }

        function drawCurve2D() {
            const canvas = document.getElementById('bezierCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const start = parseCoords(document.querySelector('input[name="start"]').value);
            const end = parseCoords(document.querySelector('input[name="end"]').value);
            const controlInput = document.querySelector('input[name="control"]').value.trim();
            const offsetX = parseFloat(document.querySelector('input[name="offset_x"]').value) || 0;
            const offsetY = parseFloat(document.querySelector('input[name="offset_y"]').value) || 0;
            const offsetZ = parseFloat(document.querySelector('input[name="offset_z"]').value) || 0;

            let control;
            if (controlInput) {
                control = parseCoords(controlInput);
            } else {
                control = [
                    (start[0] + end[0]) / 2 + offsetX,
                    (start[1] + end[1]) / 2 + offsetY,
                    (start[2] + end[2]) / 2 + offsetZ
                ];
            }

            // 2D projection
            const p0 = { x: start[0], y: start[2] };
            const p1 = { x: control[0], y: control[2] };
            const p2 = { x: end[0], y: end[2] };

            const minX = Math.min(p0.x, p1.x, p2.x);
            const minY = Math.min(p0.y, p1.y, p2.y);
            const maxX = Math.max(p0.x, p1.x, p2.x);
            const maxY = Math.max(p0.y, p1.y, p2.y);

            const padding = 40;
            const scaleX = (canvas.width - padding * 2) / (maxX - minX || 1);
            const scaleY = (canvas.height - padding * 2) / (maxY - minY || 1);

            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.01) {
                const x = (1 - t)**2 * p0.x + 2 * (1 - t) * t * p1.x + t**2 * p2.x;
                const y = (1 - t)**2 * p0.y + 2 * (1 - t) * t * p1.y + t**2 * p2.y;

                const canvasX = (x - minX) * scaleX + padding;
                const canvasY = canvas.height - ((y - minY) * scaleY + padding);

                if (t === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }

            ctx.strokeStyle = "#0077cc";
            ctx.lineWidth = 2;
            ctx.stroke();

            drawCurve3D(start, control, end);
        }

        function drawCurve3D(start, control, end) {
            const container = document.getElementById('threeContainer');
            container.innerHTML = '';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(500, 500);
            container.appendChild(renderer.domElement);

            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(...start),
                new THREE.Vector3(...control),
                new THREE.Vector3(...end)
            );

            const points = curve.getPoints(100);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const curveObject = new THREE.Line(geometry, material);
            scene.add(curveObject);

            function createSphere(pos, color) {
                const geo = new THREE.SphereGeometry(0.5, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(...pos);
                scene.add(mesh);
            }

            createSphere(start, 0x00ff00);
            createSphere(control, 0x0000ff);
            createSphere(end, 0xff0000);

            camera.position.set(control[0], control[1] + 10, control[2] + 30); // vue latérale
            camera.lookAt(...control);


            renderer.render(scene, camera);
        }

        document.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', drawCurve2D);
        });

        window.onload = drawCurve2D;
    </script>
</body>
</html>
